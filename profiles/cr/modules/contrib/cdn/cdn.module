<?php

/**
 * @file
 * Implements the core hooks, public and private functions.
 */


require_once('cdn.constants.inc');


//----------------------------------------------------------------------------
// Drupal core.

/**
 * Implements hook_file_url_alter().
 */
function cdn_file_url_alter(&$uri) {
  // Don't alter file URLs when running update.php.
  if (defined('MAINTENANCE_MODE')) {
    return;
  }

  $result = \Drupal::service('cdn.file_url_generator')->generate($uri);

  if ($result) {
    $uri = $result;
  }

  return;
  // @todo Far Future support
  $farfuture             = variable_get(CDN_BASIC_FARFUTURE_VARIABLE, CDN_BASIC_FARFUTURE_DEFAULT);
  $maintenance_mode      = variable_get('maintenance_mode', FALSE);

  if (cdn_status_is_enabled()) {
    // Alter the file path when using Origin Pull mode and using that mode's
    // Far Future setting.
    if ($mode == CDN_MODE_BASIC && $farfuture && !$maintenance_mode) {
      cdn_load_include('basic.farfuture');
      // We need the unescaped version of the URI to perform file operations.
      $uri = urldecode($uri);
      // If the file does not yet exist, perform a normal HTTP request to this
      // file, to generate it. (E.g. when ImageCache is used, this will
      // generate the derivative file.) When that fails, don't serve it from
      // the CDN.
      if (!file_exists($uri) && !_cdn_basic_farfuture_generate_file($uri, $original_uri)) {
        $path = drupal_encode_path($uri);
        return;
      }
      // Generate a unique file identifier (UFI).
      $ufi = cdn_basic_farfuture_get_identifier($uri);
      // Now that file operations have been performed, re-encode the URI.
      $uri = drupal_encode_path($uri);
      // Generate the new path.
      $uri_before_farfuture = $uri;

      // Generate a unique token to verify that the request was generated by
      // CDN. We cannot use drupal_get_token() since it depends on the user
      // session.
      $path_info = pathinfo(urldecode($uri));
      $token = drupal_hmac_base64($ufi . $path_info['filename'], drupal_get_private_key() . drupal_get_hash_salt());
      $uri = "cdn/farfuture/$token/$ufi/$uri";
    }
  }
}

/**
 * Implementation of hook_cdn_unique_file_identifier_info().
 */
function cdn_cdn_unique_file_identifier_info() {
  // Keys are machine names.
  return array(
    'md5_hash' => array(
      'label'        => t('MD5 hash'),
      'prefix'       => 'md5',
      'description'  => t('MD5 hash of the file.'),
      'filesystem'   => TRUE,
      'callback'     => 'md5_file',
    ),
    'mtime' => array(
      'label'        => t('Last modification time'),
      'prefix'       => 'mtime',
      'description'  => t('Last modification time of the file.'),
      'filesystem'   => TRUE,
      'callback'     => 'filemtime',
    ),
    'perpetual' => array(
      'label'        => t('Perpetual'),
      'prefix'       => 'perpetual',
      'description'  => t('Perpetual files never change (or are never cached
                          by the browser, e.g. video files).'),
      'filesystem'   => FALSE,
      'value'        => 'forever',
    ),
    'drupal_version' => array(
      'label'        => t('Drupal version'),
      'prefix'       => 'drupal',
      'description'  => t('Drupal core version â€” this should only be applied
                          to files that ship with Drupal core.'),
      'filesystem'   => FALSE,
      'value'        => VERSION,
    ),
    'drupal_cache' => array(
      'label'        => t('Drupal cache'),
      'prefix'       => 'drupal-cache',
      'description'  => t('Uses the current Drupal cache ID
                          (<code>css_js_query_string</code>). This ID is
                          updated automatically whenever the Drupal cache is
                          flushed (e.g. when you submit the modules form). Be
                          aware that this can change relatively often, forcing
                          redownloads by your visitors.'),
      'filesystem'   => FALSE,
      'value'        => variable_get('css_js_query_string', 0),
    ),
    'deployment_id' => array(
      'label'        => t('Deployment ID'),
      'prefix'       => 'deployment',
      'description'  => t('A developer-defined deployment ID. Can be an
                          arbitrary string or number, as long as it uniquely
                          identifies deployments and therefore the affected
                          files.<br />
                          Define this deployment ID in any enabled module or
                          in <code>settings.php</code> as the
                          <code>CDN_DEPLOYMENT_ID</code>
                          constant, and it will be picked up instantaneously.'),
      'filesystem'   => FALSE,
      'callback'     => '_cdn_ufi_deployment_id',
    ),
  );
}

/**
 * Implements hook_menu().
 */
function cdn_menu() {
  // Origin Pull mode's Far Future expiration support.
  $items['cdn/farfuture/%/%/%menu_tail'] = array(
    'title'            => 'Download a far futured file',
    'access callback'  => TRUE,
    'page callback'    => 'cdn_basic_farfuture_download',
    'page arguments'   => array(2, 3, 4),
    'type'             => MENU_CALLBACK,
    'load arguments'   => array('%map', '%index'),
    'file'             => 'cdn.basic.farfuture.inc',
  );
  $items['cdn/farfuture/reverse-proxy-test/%'] = array(
    'title'            => 'Far Future reverse proxy test',
    'access callback'  => TRUE,
    'page callback'    => 'cdn_basic_farfuture_reverseproxy_test',
    'page arguments'   => array(3),
    'type'             => MENU_CALLBACK,
    'file'             => 'cdn.basic.farfuture.inc',
  );

  return $items;
}

/**
 * Implements hook_boot().
 */
function cdn_boot() {
  // Bail if the status is "disabled" (i.e. don't when "enabled" or "testing").
  if (variable_get(CDN_STATUS_VARIABLE, CDN_DISABLED) === CDN_DISABLED) {
    return;
  }

  // Inspired by common.inc/_drupal_bootstrap_full().
  require_once DRUPAL_ROOT . '/includes/common.inc';
  require_once DRUPAL_ROOT . '/' . variable_get('path_inc', 'includes/path.inc');
  require_once DRUPAL_ROOT . '/includes/unicode.inc';

  // Prevent the CDN from returning content pages. We only want the CDN to
  // return static files like images, CSS files, JavaScript files, etc. By
  // default it will return anything. Since those static files aren't served by
  // Drupal.
  $redirect_url = _cdn_seo_should_redirect(current_path());
  if ($redirect_url !== FALSE) {
    // A 301 is SEO friendly, as it tells the search engine what the canonical
    // URL is for this content.
    header('HTTP/1.0 301 Moved Permanently');
    // @see http://googlewebmastercentral.blogspot.com/2011/06/supporting-relcanonical-http-headers.html
    header('Link: <' . $redirect_url . '>; rel="canonical"');
    header('Location: ' . $redirect_url);

    // To ensure this redirect occurs immediately we don't use drupal_exit().
    exit();
  }
}


//----------------------------------------------------------------------------
// Public functions.

/**
 * Helper function to efficiently load include files for this module.
 */
function cdn_load_include($basename) {
  module_load_include('inc', 'cdn', "cdn.$basename");
}


//----------------------------------------------------------------------------
// Private functions.

/**
 * Callback for generating a unique file identifier.
 *
 * @param $path
 *   The file path to the file for which to generate a  unique identifier.
 */
function _cdn_ufi_deployment_id($path) {
  return CDN_DEPLOYMENT_ID;
}

/**
 * Determines whether a redirect should be performed for the given path for SEO
 * considerations (prevent duplicate HTML content on the CDN), and if so, the
 * URL to which the requesting User Agent should be redirected.
 *
 * @param $path
 *   The path for which to determine the redirect URL.
 * @return
 *   FALSE if no redirect should occur, or the URL to redirect to.
 */
function _cdn_seo_should_redirect($path) {
  if (variable_get(CDN_SEO_REDIRECT_VARIABLE, CDN_SEO_REDIRECT_DEFAULT)) {
    // If the path ends in an extension that is not in the list of forbidden
    // extensions, then return FALSE to indicate that no redirect should occur.
    // The rationale is: menu_get_item() doesn't allow us to detect whether a
    // page callback will generate a file; hence we (ab)use this heuristic.
    // An added benefit is that we don't need the menu system to be loaded,
    // meaning that we can do all of this during hook_boot(), meaning we can use
    // this same code for cached pages, which we need to support anyway.
    // @todo: improve Drupal core so that contrib modules can know whether
    // certain menu callbacks generate files or not.
    $forbidden_extensions = variable_get(CDN_SEO_FORBIDDEN_EXTENSIONS_VARIABLE, CDN_SEO_FORBIDDEN_EXTENSIONS_DEFAULT);
    $extension = drupal_strtolower(pathinfo($path, PATHINFO_EXTENSION));
    if (!empty($extension) && !in_array($extension, explode("\n", $forbidden_extensions))) {
      return FALSE;
    }

    // Use case-insensitive substring matching to match the current User-Agent
    // to the list of CDN user agents.
    if (isset($_SERVER['HTTP_USER_AGENT'])) {
      $ua = drupal_strtolower($_SERVER['HTTP_USER_AGENT']);
      $cdn_user_agents = explode("\n", drupal_strtolower(variable_get(CDN_SEO_USER_AGENTS_VARIABLE, CDN_SEO_USER_AGENTS_DEFAULT)));
      foreach ($cdn_user_agents as $cdn_ua) {
        if (strstr($ua, trim($cdn_ua))) {
          return url($path, array('absolute' => TRUE));
        }
      }
    }
  }
  return FALSE;
}
